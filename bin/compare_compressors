#!/usr/bin/env ruby
# frozen_string_literal: true

require 'compare_compressors'

require 'getoptlong'
require 'csv'

include CompareCompressors

output = :csv
plot_terminal = 'png'
plot_output = 'compare_compressors.png'
group_scale = 1.0
gibyte_cost = 0.023 # per GiB*month
hour_cost = 0.047 # per hour

getopt = GetoptLong.new(
  ['--help',     '-h',   GetoptLong::NO_ARGUMENT],
  ['--version',  '-v',   GetoptLong::NO_ARGUMENT],
  ['--output',           GetoptLong::REQUIRED_ARGUMENT],
  ['--gnuplot-terminal', GetoptLong::REQUIRED_ARGUMENT],
  ['--gnuplot-output',   GetoptLong::REQUIRED_ARGUMENT]
)

opts = {}
getopt.each do |opt, arg|
  case opt
  when '--help' then
    print_usage
    exit
  when '--version' then
    puts "compare_compressors-#{CompareCompressors::VERSION}"
    exit
  when '--output' then
    raise "bad output: #{arg}" unless %w(gnuplot csv).member?(arg)
    output = arg.to_sym
  when '--gnuplot-terminal' then
    plot_terminal = arg
  when '--gnuplot-output' then
    plot_output = arg
  else
    opts[opt] = arg
  end
end

def print_usage
  puts 'TODO: USAGE'
end

targets = ARGV
num_targets = targets.size
if num_targets.zero?
  print_usage
  exit
end
targets.each do |target|
  raise "missing target #{target}" unless File.exist?(target)
end

if File.exist?('res.dump')
  results = Marshal.load(File.open('res.dump'))
else
  results = []
  COMPRESSORS.each do |compressor|
    targets.each do |target|
      results.concat(compressor.compress(target))
    end
  end

  File.open('res.dump', 'wb') do |f|
    Marshal.dump(results, f)
  end
end

# ideas
# - log size scale may make sense
# - find the initial size first for each target, then average the deltas
# - if we take a byte cost and a time cost, the axes could be rescaled into
#   cost
# - but my original idea still seems OK: draw some cost contours

case output
when :csv then
  CSV do |csv|
    csv << Result.members
    results.each do |result|
      csv << result.to_a
    end
  end
when :gnuplot then
  puts "set terminal #{plot_terminal} size 640, 480"
  puts "set output '#{plot_output}'"

  group_results = GroupResult.from_results(
    results, group_scale, gibyte_cost, hour_cost
  )
  group_results = GroupResult.find_non_dominated(group_results)

  names = results.map(&:compressor_name).uniq.sort
  names.each do |name|
    name_results =
      group_results.select { |result| result.compressor_name == name }
    puts "$#{name} << EOD"
    name_results.each do |name_result|
      puts name_result.to_a.join(' ')
    end
    puts 'EOD'
  end

  plots = names.map do |name|
    "'$#{name}' using 3:4:0 with points nocontour title '#{name}'"
  end

  plots.concat(names.map do |name|
    "'$#{name}' using 3:4:0:2 with labels nocontour notitle"
  end)

  # cost contours
  # if the axes are x=time and y=size, we want to plot the surface
  # z = scale * (x * hour_cost / 3600.0 + y * gibyte_cost / 1024**3)
  x_coef = hour_cost
  y_coef = gibyte_cost
  plots.unshift "#{x_coef} * x + #{y_coef} * y with labels boxed notitle nosurface"
  plots.unshift "#{x_coef} * x + #{y_coef} * y with line palette notitle nosurface"

  puts 'set view map'
  puts 'set contour'
  puts 'set cntrlabel font ",8"'
  puts %(
  set palette gray
  set style textbox opaque noborder
  set xlabel "Compression Time (hours)"
  set ylabel "Compressed Size (GiB)"
  set key outside
  set lmargin 5
  unset colorbox
)
  # puts 'set logscale y'
  # puts 'set autoscale fix'
  puts "splot #{plots.join(", \\\n  ")}"
end
